= Serialbench: Ruby serialization library performance benchmarker

image:https://img.shields.io/gem/v/serialbench.svg["Gem Version", link="https://rubygems.org/gems/serialbench"]
image:https://github.com/metanorma/serialbench/actions/workflows/ci.yml/badge.svg["Build Status", link="https://github.com/metanorma/serialbench/actions/workflows/ci.yml"]
image:https://github.com/metanorma/serialbench/actions/workflows/benchmark.yml/badge.svg["Benchmark Status", link="https://github.com/metanorma/serialbench/actions/workflows/benchmark.yml"]
image:https://img.shields.io/github/issues-pr-raw/metanorma/serialbench.svg["Pull Requests", link="https://github.com/metanorma/serialbench/pulls"]

== Overview

Serialbench is a comprehensive benchmarking suite that evaluates the performance of popular Ruby serialization libraries across multiple formats. It provides detailed performance comparisons and analysis to help developers make informed decisions when choosing serialization libraries for their Ruby applications.

**Supported Formats**: XML, JSON, YAML, TOML, and more

**Key Metrics**: Parsing speed, generation speed, memory usage, streaming capabilities, and feature completeness

**Docker Support**: Multi-Ruby version benchmarking with automated result aggregation and GitHub Pages generation

== Supported serialization libraries

=== XML serialization libraries

==== High-performance libraries

* **https://github.com/ohler55/ox[Ox]** v2.14.23 - Ultra-fast C extension optimized for speed and low memory usage
* **https://github.com/xml4r/libxml-ruby[LibXML]** v4.1.2 - Ruby bindings for libxml2 with excellent performance characteristics

==== Feature-rich libraries

* **https://github.com/sparklemotion/nokogiri[Nokogiri]** v1.18.8 - Most popular XML/HTML parser with XPath, CSS selectors, and comprehensive DOM manipulation
* **https://github.com/YorickPeterse/oga[Oga]** v3.4 - Pure Ruby XML parser with XPath support and streaming capabilities

==== Built-in libraries

* **https://github.com/ruby/rexml[REXML]** v3.4.1 - Ruby's standard library XML parser with streaming support (reference implementation)

=== JSON serialization libraries

==== High-performance libraries

* **https://github.com/ohler55/oj[Oj]** v3.16.11 - Ultra-fast JSON parser with multiple parsing modes and streaming support
* **https://github.com/brianmario/yajl-ruby[YAJL]** v1.4.3 - Yet Another JSON Library with excellent streaming capabilities

==== Built-in libraries

* **https://github.com/flori/json[JSON]** v2.12.2 - Ruby's standard library JSON parser (reference implementation)

=== YAML serialization libraries

==== Built-in libraries

* **https://github.com/ruby/psych[Psych]** v5.1.2 - Ruby's standard library YAML parser with excellent performance and full YAML 1.1 support

==== Legacy libraries

* **https://github.com/ruby/syck[Syck]** v1.5.1.1 - Legacy YAML parser (Ruby < 1.9.3) with fast parsing for simple documents

=== TOML serialization libraries

==== High-performance libraries

* **https://github.com/fbernier/tomlib[Tomlib]** v0.7.3 - Fast TOML parser implemented in C

==== Standard libraries

* **https://github.com/emancu/toml-rb[TOML-RB]** v2.2.0 - Pure Ruby TOML parser with good compatibility

== Installation

Add this line to your application's Gemfile:

[source,ruby]
----
gem 'serialbench'
----

And then execute:

[source]
----
$ bundle install
----

Or install it yourself as:

[source]
----
$ gem install serialbench
----

=== XML library dependencies

To run benchmarks for all supported XML libraries, install the following gems:

[source]
----
# Core XML libraries
$ gem install ox nokogiri libxml-ruby oga

# Additional format libraries (for comparison)
$ gem install oj toml-rb

# Memory profiling support
$ gem install memory_profiler
----

NOTE: REXML, JSON, and Psych (YAML) are included with Ruby and require no additional installation.

=== Library-specific installation notes

==== Ox

High-performance C extension requiring compilation:

[source]
----
$ gem install ox
----

==== Nokogiri

May require system dependencies on some platforms:

[source]
----
# macOS with Homebrew
$ brew install libxml2 libxslt
$ gem install nokogiri

# Ubuntu/Debian
$ sudo apt-get install libxml2-dev libxslt1-dev
$ gem install nokogiri
----

==== LibXML

Ruby bindings for libxml2:

[source]
----
# macOS with Homebrew
$ brew install libxml2
$ gem install libxml-ruby

# Ubuntu/Debian
$ sudo apt-get install libxml2-dev
$ gem install libxml-ruby
----

==== Oga

Pure Ruby implementation with no system dependencies:

[source]
----
$ gem install oga
----

== Docker multi-Ruby version benchmarking

Serialbench includes comprehensive Docker support for running benchmarks across multiple Ruby versions in isolated environments. This enables accurate performance comparisons and ensures consistent results across different Ruby implementations.

=== Quick start with Docker

==== Prerequisites

* Docker installed and running
* Bash shell (Linux/macOS/WSL)

==== Running multi-Ruby benchmarks

[source]
----
# From the project root directory
$ ./docker/run-benchmarks.sh
----

This automated script will:

. **Build Docker images** for Ruby 3.0, 3.1, 3.2, 3.3, and 3.4
. **Run comprehensive benchmarks** in each isolated environment
. **Merge results** from all Ruby versions into comparative datasets
. **Generate GitHub Pages** with interactive multi-version reports

==== Results structure

Results are organized in `docker-results/`:

[source]
----
docker-results/
├── ruby-3.0/              # Ruby 3.0 individual results
│   ├── benchmark.log       # Execution log
│   ├── data/
│   │   ├── results.json    # Raw benchmark data
│   │   └── results.yaml    # YAML format results
│   ├── reports/
│   │   └── benchmark_report.html
│   └── assets/
├── ruby-3.1/              # Ruby 3.1 individual results
├── ruby-3.2/              # Ruby 3.2 individual results
├── ruby-3.3/              # Ruby 3.3 individual results
├── ruby-3.4/              # Ruby 3.4 individual results
├── merged/                 # Aggregated cross-version results
│   └── merged_results.json # Combined performance data
└── docs/                   # GitHub Pages ready output
    ├── index.html          # Interactive comparison report
    ├── styles.css          # Report styling
    └── merged_results.json # Data for interactive charts
----

=== Manual Docker usage

==== Build image for specific Ruby version

[source]
----
$ docker build \
  --build-arg RUBY_VERSION=3.3 \
  -t serialbench:ruby-3.3 \
  -f docker/Dockerfile.benchmark \
  .
----

==== Run benchmarks in container

[source]
----
# Create results directory
$ mkdir -p results

# Run benchmarks with volume mounting
$ docker run \
  --rm \
  -v $(pwd)/results:/app/results \
  serialbench:ruby-3.3
----

==== Custom configuration

[source]
----
# Use custom config file
$ docker run \
  --rm \
  -v $(pwd)/results:/app/results \
  -v $(pwd)/config:/app/config \
  serialbench:ruby-3.3 \
  bundle exec serialbench benchmark --config config/ci.yml
----

=== Supported Ruby versions

The Docker setup supports the following Ruby versions:

* **Ruby 3.0** - Stable release with good performance baseline
* **Ruby 3.1** - Improved performance and new features
* **Ruby 3.2** - Enhanced YJIT and memory optimizations
* **Ruby 3.3** - Latest stable with performance improvements
* **Ruby 3.4** - Current development version

Each version includes all supported serialization libraries:

* **XML**: REXML (built-in), Ox, Nokogiri, Oga, LibXML
* **JSON**: JSON (built-in), Oj, YAJL
* **YAML**: Psych (built-in), Syck
* **TOML**: TOML-RB, Tomlib

=== Environment variables

The Docker images support these environment variables:

* `BUNDLE_PATH` - Bundle installation path
* `BUNDLE_BIN` - Bundle binary path
* `PATH` - System PATH including bundle binaries
* `RUBY_VERSION` - Ruby version for build-time configuration

=== Result aggregation and GitHub Pages

==== Merging multi-version results

The Docker workflow automatically merges results from all Ruby versions:

[source]
----
# Manual result merging
$ serialbench merge_results \
  docker-results/ruby-3.0 \
  docker-results/ruby-3.1 \
  docker-results/ruby-3.2 \
  docker-results/ruby-3.3 \
  docker-results/ruby-3.4 \
  docker-results/merged
----

==== GitHub Pages generation

Generate interactive HTML reports ready for GitHub Pages deployment:

[source]
----
# Generate GitHub Pages from multi-version results
$ serialbench github_pages \
  docker-results/ruby-3.0 \
  docker-results/ruby-3.1 \
  docker-results/ruby-3.2 \
  docker-results/ruby-3.3 \
  docker-results/ruby-3.4 \
  docker-results/docs
----

The generated GitHub Pages include:

* **Interactive Performance Charts**: Compare serializers across Ruby versions
* **Multi-Version Analysis**: See how performance changes between Ruby releases
* **Environment Details**: Ruby versions, platforms, and library versions
* **Responsive Design**: Works on desktop and mobile devices
* **Direct Deployment**: Ready for GitHub Pages, Netlify, or any static hosting

==== Deploying to GitHub Pages

. **Commit the generated files**:
+
[source]
----
$ git add docker-results/docs/
$ git commit -m "Add multi-Ruby benchmark results"
$ git push origin main
----

. **Enable GitHub Pages** in repository settings:
.. Go to Settings → Pages
.. Set source to "Deploy from a branch"
.. Select branch containing the `docs/` folder
.. Set folder to `/docker-results/docs`

. **Access your results** at: `https://yourusername.github.io/yourrepo/`

=== Troubleshooting Docker issues

==== Build failures

Check build logs for specific Ruby versions:

[source]
----
$ cat docker-results/build-ruby-3.3.log
----

Common build issues:

* **Missing system dependencies**: Ensure libxml2-dev and libxslt1-dev are available
* **Network timeouts**: Retry the build or use a different network
* **Disk space**: Ensure sufficient disk space for multiple Ruby images

==== Runtime failures

Check benchmark execution logs:

[source]
----
$ cat docker-results/ruby-3.3/benchmark.log
----

Common runtime issues:

* **Memory constraints**: Increase Docker memory allocation
* **Timeout issues**: Some benchmarks may take longer on slower systems
* **Permission errors**: Ensure proper volume mounting permissions

==== Docker system issues

Verify Docker is running properly:

[source]
----
$ docker info
$ docker system df  # Check disk usage
$ docker system prune  # Clean up unused resources
----

Clean up Serialbench Docker resources:

[source]
----
# Remove all Serialbench images
$ docker rmi $(docker images serialbench -q)

# Remove all containers
$ docker container prune
----

=== Customization options

==== Adding Ruby versions

Edit the `RUBY_VERSIONS` array in `docker/run-benchmarks.sh`:

[source,bash]
----
RUBY_VERSIONS=("3.0" "3.1" "3.2" "3.3" "3.4" "head")
----

==== Custom benchmark configuration

Create custom config files in the `config/` directory:

[source,yaml]
----
# config/custom.yml
formats:
  - xml
  - json
iterations: 50
warmup: 5
data_sizes:
  - small
  - medium
----

Reference the custom config in the run script:

[source,bash]
----
# In docker/run-benchmarks.sh
CONFIG_FILE="config/custom.yml"
----

==== Output directory customization

Change the output directory in the run script:

[source,bash]
----
# In docker/run-benchmarks.sh
OUTPUT_DIR="my-benchmark-results"
----

=== Integration with CI/CD

==== GitHub Actions integration

The Docker setup integrates seamlessly with GitHub Actions:

[source,yaml]
----
# .github/workflows/benchmark.yml
name: Multi-Ruby Benchmarks

on:
  schedule:
    - cron: '0 2 * * 0'  # Weekly on Sunday at 2 AM
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  benchmark:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Run Docker Benchmarks
        run: ./docker/run-benchmarks.sh

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results
          path: docker-results/

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./docker-results/docs

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: benchmark
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
----

==== Performance considerations

* **Parallel builds**: Docker builds can run in parallel for faster execution
* **Build caching**: Subsequent runs use cached layers for faster builds
* **Memory profiling**: Enabled by default but can be disabled for faster runs
* **Result compression**: Large result files can be compressed for storage

=== Security considerations

* **Containers run with minimal privileges**: No root access required
* **No network access during benchmarks**: Isolated execution environment
* **Volume mounting**: Results written only to specified mounted volumes
* **Image scanning**: Regular security updates for base Ruby images

== Usage

=== Command line interface

==== Basic usage

Run benchmarks for all available formats:

[source]
----
$ serialbench benchmark
----

List all available serializers:

[source]
----
$ serialbench list
----

Show help information:

[source]
----
$ serialbench help
$ serialbench help benchmark
----

Show version:

[source]
----
$ serialbench version
----

==== Format-specific benchmarks

===== XML benchmarks

Run all XML library benchmarks:

[source]
----
$ serialbench benchmark --formats xml
----

Test specific XML libraries:

[source]
----
$ serialbench benchmark --formats xml --parsers ox,nokogiri
$ serialbench benchmark --formats xml --parsers rexml,oga,libxml
----

XML-only parsing performance:

[source]
----
$ serialbench benchmark --formats xml --parsing-only
----

XML generation benchmarks:

[source]
----
$ serialbench benchmark --formats xml --generation-only
----

XML streaming/SAX parsing:

[source]
----
$ serialbench benchmark --formats xml --streaming-only
----

===== JSON benchmarks

Run all JSON library benchmarks:

[source]
----
$ serialbench benchmark --formats json
----

Test specific JSON libraries:

[source]
----
$ serialbench benchmark --formats json --parsers oj,json
$ serialbench benchmark --formats json --parsers yajl,oj
----

===== TOML benchmarks

Run all TOML library benchmarks:

[source]
----
$ serialbench benchmark --formats toml
----

Test specific TOML libraries:

[source]
----
$ serialbench benchmark --formats toml --parsers tomlib,toml-rb
----

==== Cross-format comparisons

Compare XML vs JSON performance:

[source]
----
$ serialbench benchmark --formats xml json
----

Compare all supported formats:

[source]
----
$ serialbench benchmark --formats xml json toml
----

==== Advanced options

Memory profiling across formats:

[source]
----
$ serialbench benchmark --memory-profiling
----

Generate detailed reports:

[source]
----
$ serialbench benchmark --detailed-reports
----

Output results in JSON format:

[source]
----
$ serialbench benchmark --output-format json
----

Custom data sizes and iterations:

[source]
----
$ serialbench benchmark --data-sizes small,medium --iterations 100
----

=== Multi-Ruby version comparison

Merge benchmark results from multiple Ruby versions:

[source]
----
$ serialbench merge_results ruby-3.0/results ruby-3.1/results ruby-3.2/results merged_output/
----

Generate GitHub Pages HTML from multiple benchmark runs:

[source]
----
$ serialbench github_pages ruby-3.0/results ruby-3.1/results ruby-3.2/results docs/
----

This creates an interactive HTML report with:

* **Multi-version charts**: Compare performance across Ruby versions
* **Interactive navigation**: Switch between parsing, generation, streaming, and memory usage
* **Environment details**: Ruby versions, platforms, and serializer versions
* **GitHub Pages ready**: Deploy directly to GitHub Pages for public sharing

=== Programmatic usage

==== Basic benchmark execution

[source,ruby]
----
require 'serialbench'

# Run all benchmarks for all formats
results = Serialbench.run_benchmarks

# Run benchmarks for specific formats
results = Serialbench.run_benchmarks(formats: [:xml, :json])

# Generate comprehensive reports
report_files = Serialbench.generate_reports(results)

puts "HTML report: #{report_files[:html]}"
puts "Charts generated: #{report_files[:charts].length}"
----

==== Custom benchmark configuration

[source,ruby]
----
require 'serialbench'

# Create a custom benchmark runner
runner = Serialbench::BenchmarkRunner.new(formats: [:json, :xml])

# Run specific benchmark categories
parsing_results = runner.run_parsing_benchmarks
generation_results = runner.run_generation_benchmarks
memory_results = runner.run_memory_benchmarks

# Format and display results
formatter = Serialbench::ResultFormatter.new(runner.results)
puts formatter.summary
----

==== Individual serializer testing

[source,ruby]
----
require 'serialbench'

# Test a specific JSON serializer
oj_serializer = Serialbench::Serializers::Json::OjSerializer.new

if oj_serializer.available?
  json_content = '{"users": [{"name": "Alice", "age": 30}]}'

  # Parse JSON
  data = oj_serializer.parse(json_content)

  # Generate JSON
  json_output = oj_serializer.generate(data, pretty: true)

  # Stream parsing (if supported)
  if oj_serializer.supports_streaming?
    oj_serializer.stream_parse(json_content) do |event, data|
      puts "Event: #{event}, Data: #{data}"
    end
  end

  puts "Serializer: #{oj_serializer.name}"
  puts "Version: #{oj_serializer.version}"
  puts "Format: #{oj_serializer.format}"
  puts "Features: #{oj_serializer.features}"
end
----

==== Check available serializers

[source,ruby]
----
require 'serialbench'

# List all available serializers
Serialbench.available_serializers.each do |serializer_class|
  serializer = serializer_class.new
  puts "#{serializer.format}: #{serializer.name} v#{serializer.version}"
end

# List serializers for specific format
Serialbench.available_serializers(:json).each do |serializer_class|
  serializer = serializer_class.new
  puts "JSON: #{serializer.name} v#{serializer.version}"
end
----

== Benchmark categories

=== Parsing performance

Measures the time required to parse serialized data into Ruby objects.

* **Small files**: ~1KB configuration-style documents
* **Medium files**: ~1MB API responses with 1,000 records
* **Large files**: ~10MB data exports with 10,000 records

=== Generation performance

Tests how quickly libraries can convert Ruby objects into serialized strings.

=== Streaming performance

Evaluates streaming event-based parsing performance for libraries that support
it, which processes data sequentially and is memory-efficient for large files.

=== Memory usage analysis

Profiles memory allocation and retention during serialization operations using
the `memory_profiler` gem.


== Output and reports

=== Generated files

Running benchmarks creates the following output structure:

[source]
----
results/
├── reports/
│   ├── benchmark_report.html    # Main HTML report
│   └── benchmark_report.adoc    # AsciiDoc source
├── charts/
│   ├── parsing_performance.svg
│   ├── generation_performance.svg
│   ├── streaming_performance.svg
│   ├── memory_usage_comparison.svg
│   └── format_comparison.svg
├── data/
│   ├── results.json             # Raw benchmark data
│   └── results.csv              # CSV export
└── assets/
    └── css/
        └── benchmark_report.css # Report styling
----

=== Report features

* **Multi-format comparison**: Compare XML, JSON, and TOML performance
* **Interactive charts**: SVG-based performance visualizations
* **Comparative analysis**: Side-by-side library comparisons
* **Performance rankings**: Fastest to slowest for each category
* **Memory profiling**: Detailed memory allocation analysis
* **Feature matrix**: Capability comparison across libraries
* **Environment details**: Ruby version, platform, and library versions

=== Sample output

[example]
====
Serialbench - Comprehensive Serialization Performance Tests
===========================================================
Environment: Ruby 3.3.2 on arm64-darwin23
Timestamp: 2025-06-07T10:30:00Z

Available serializers: rexml, json, oj, toml-rb
Test formats: xml, json, toml
Test data sizes: small, medium, large

Parsing Performance:
  Small files:
    JSON/oj: 0.08ms
    JSON/json: 0.12ms
    XML/rexml: 0.45ms
    TOML/toml-rb: 0.52ms

  Medium files:
    JSON/oj: 8.23ms
    JSON/json: 12.67ms
    XML/rexml: 28.45ms
    TOML/toml-rb: 35.21ms
====

== Methodology

=== Performance measurement

* Each test runs multiple iterations with warmup iterations
* Memory profiling uses 10 iterations to reduce noise
* Results show average performance across all iterations
* Benchmarks use Ruby's `Benchmark.realtime` for precise timing

=== Test data

==== Synthetic datasets

The benchmark suite uses carefully crafted synthetic data that represents common real-world scenarios:

* **Configuration files**: Small, nested structures typical of application settings
* **API responses**: Medium-sized documents with repeated record structures
* **Data exports**: Large documents with extensive hierarchical data

==== Multi-format consistency

* Equivalent data structures across XML, JSON, and TOML formats
* Consistent complexity and nesting levels
* Representative of real-world usage patterns

=== Statistical considerations

* Multiple iterations reduce timing variance
* Warmup iterations eliminate JIT compilation effects
* Memory measurements account for garbage collection
* Results include both absolute and relative performance metrics

== Development

=== Running tests

[source]
----
$ bundle exec rake
$ bundle exec rspec
----

=== Contributing

. Fork the repository
. Create your feature branch (`git checkout -b feature/my-new-feature`)
. Commit your changes (`git commit -am 'Add some feature'`)
. Push to the branch (`git push origin feature/my-new-feature`)
. Create a new Pull Request

=== Adding new serializers

To add support for additional serialization libraries:

. Create a new serializer class in `lib/serialbench/serializers/{format}/`
. Inherit from the appropriate base class (`BaseXmlSerializer`, `BaseJsonSerializer`, etc.)
. Implement the required methods: `parse`, `generate`, `name`, `version`
. Add the serializer to the registry in `lib/serialbench/serializers.rb`
. Update documentation and tests

==== Example: Adding a new JSON serializer

[source,ruby]
----
# lib/serialbench/serializers/json/yajl_serializer.rb
class YajlSerializer < BaseJsonSerializer
  def available?
    require_library('yajl')
  end

  def name
    'yajl'
  end

  def version
    require 'yajl'
    Yajl::VERSION
  end

  def parse(json_string)
    require 'yajl'
    Yajl::Parser.parse(json_string)
  end

  def generate(object, options = {})
    require 'yajl'
    Yajl::Encoder.encode(object)
  end
end
----

== Architecture

=== Serializer hierarchy

[source]
----
BaseSerializer
├── BaseXmlSerializer
│   └── RexmlSerializer
├── BaseJsonSerializer
│   ├── JsonSerializer
│   └── OjSerializer
└── BaseTomlSerializer
    └── TomlRbSerializer
----

=== Key components

* **Serializers**: Individual library implementations
* **BenchmarkRunner**: Orchestrates benchmark execution
* **ResultFormatter**: Formats and displays results
* **ReportGenerator**: Creates HTML/AsciiDoc reports
* **ChartGenerator**: Creates performance visualizations
* **MemoryProfiler**: Analyzes memory usage patterns

== Research and references

This benchmarking suite was developed based on research from:

* https://www.ohler.com/dev/xml_with_ruby/xml_with_ruby.html[XML with Ruby performance analysis]
* https://gist.github.com/danneu/3977120[Ruby XML parser comparison]
* https://gist.github.com/adilosa/d4277dc1c683da91990515352ffe5420[XML parsing benchmarks]

== Copyright

This gem is developed, maintained and funded by
https://www.ribose.com[Ribose Inc.]

== License

The gem is available as open source under the terms of the
https://opensource.org/licenses/BSD-2-Clause[2-Clause BSD License].
